# Task implementation notes

## Introduction

Even though on the surface this project looks simple, there is a huge amount of details to consider when implementing it. While some decisions are rather straightforward, a lot of others require considering many alternatives. Oftentimes, there is no single best solution for a situation, but different solutions with different sets of pros and cons.

If You see something unexpected or weird in the implementation, there is probably a reason for that. I would be happy to answer any questions that You might have, so please feel free to reach out!

## Architecture and code structure

The API tests check the system like a black box.

## Future considerations and potential improvements

As the codebase evolves, a list of things should be considered:

* **Command interfaces**. TODO: Having dedicated interfaces for each command type vs. a few generic interfaces for all commands. The first variant is nicer for things like readability and less visual clutter, but the later variant is more useful if trying to add "special" command-based code that follows some design pattern, like a decorated (for example, for logging the request and response of a command or to do performance benchmarks).
* **"Money" data type**. TODO: A dedicated data type could be used to wrap money-related operations and to make it more explicit that the contained decimal value represents real-word money, especially since anything related to that should be handled with care (if some handling or calculations is incorrect somewhere, the software's client or the owners might lose money). An additional benefit of the "Money" class/struct/record/record struct would be that it would help with handling currency conversions easier. Related link: https://martinfowler.com/eaaCatalog/money.html
* **Test coverage improvements**. TODO: There is still code that could be covered by tests, such as the message queue handling code, the repositories, and some utility code.
* **Cover and claim delete endpoints**. Due to the way the audit and claim delete operations were being done in the original version of the code, it was somewhat ambiguous if they should return something as a result. In most cases, delete operations are expected to return no results, but occasionally API designers return the last state of the object being deleted as part of the delete operation. This can happen, for example, if there is a need to display the deleted object in some dialog window or in some similar way as a deletion success notification. In practice though, APIs that had such results returned would get the results ignored anyway (the object was being returned "just in case" it will be needed at some point in development, but such situations never happened). Initially, I implemented the API with the objects being returned but later decided to stick to returning nothing (the results returning version was removed via git commits such as 590636c8c30b2885e77753d52c857679fc4bd671; though please ignore some of the messy parts of the code as the code was still in flux).
* **Full system tests**. In addition to the current tests, it would be great to create some tests that cover the whole system, which would include the API and the audit message processing process working together and their cooperation results getting checked (the API sends a message to the queue, the message process consumes the message and that causes an SQL database entry to be made).
* ??? TODO: --> Make some or all record types into record struct types? Most likely for the command request and responses
* ??? TODO: --> Empty interfaces that just inherit other interfaces --> Command interfaces and repository interfaces. The repository ones are ok, but command ones are just to make thing look nicer.
* **Controller dependency injection**. TODO: Finish! --> Injecting commands via constructor directly vs. injecting via a grouping object vs. injecting via injectable parameter in controller action. One alternative that aids dependency injection is the MediatR, but has two problems: it uses reflection to find the handlers and also gets used in the Application project, which should be free of libraries, if possible. Using the MediatR feels like a workaround for issues with Controllers existing in the first place!
* **Resource ownership**. The system uses the following resources: a Cosmos DB database for claims (and covers), an SQL Server database for audit and a RabbitMQ queue for sending and receiving messages from the API to the audit message processing process. The API upgrades the claims database on startup, the message processing process does the same for the audit database, and the queue gets created by either party, depending on which program starts first. This might not be ideal, especially if multiple copies of either program get instantiated for sake scaling the system. The creation of all the mentioned resources might need to be migrated to a separate executable that is run independently, being triggered by either code merges or other deployment pipeline triggers (which may or may not be manual, depending on the needs). In addition, some infrastructure as code should probably be used.
* **Database handling in tests**. API tests delete the main Cosmos DB database before each test is run. A few related considerations:
  * If the tests successfully creates the database via the API initialization, the database will still remain created and will be in the state of the last test that ran. This aids in debugging that test and might be considered desirable for that reason. If that is undesirable, the clean-up could be moved to after each test, or after all of them (more on that below);
  * API tests are rather slow in general and the additional step of deleting the database for each test makes them even slower. The main reason to keep it that way is to keep each test isolated from each other. An alternative approach could be use where the database deletion occurs just once for all the API tests. This would improve performance, but it would require changes to most of the tests. Most likely, they would need to be made ordered, so that each test knows the exact state of the database. Though there would be a benefit of simplifying certain tests, where multiple endpoints interact. For example, to get a cover via HTTP GET, one needs to create it via an HTTP POST. If tests are isolated (the database gets deleted for each test), the cover creation POST calls might need to be added to each test that later uses that created cover. But if tests are interconnected (a single database delete per all tests in a batch), an earlier test might populate the database with a cover that the later test get then retrieve.
* **Validation**. The deletion of a cover should handle the deletion of related claims in one of the following ways, because a claim without a cover cannot exist on it's own (it's a child the claim):
  * All child claims should simply be deleted, if any;
  * An exceptions should be raised if at least one claim is attached to a cover.
* **Minimal API**. It might be desirable to replace controllers with the minimal API of ASP.NET due the following reasons (which also tend to apply to application service classes):
  * On a more philosophical level, I would argue that controllers do not represent any "real" concept in programming. Ideally, all names in the code should belong to the domain that they represent (in here, "domain" is a more broader term than the application domain; the domain can be that of data structures with its queues, arrays, etc.; or the domain can be that of databases with its tables, columns, rows, etc.). The term "controller" is a rather vague name and does not reflect it's purpose. In addition, it acts more as namespace for controller actions, rather than a "real" object. When an HTTP call is made to an API, the related controller gets instantiated and a single method on it gets called. In general, when using a "real" object (if well designed) it is normal to call multiple methods on a single instance of an object during the object's lifetime.
  * In more practical terms, controllers tend to attract more dependencies with each new controller action. But, more importantly, the dependencies can become injected only because a single action might need it.